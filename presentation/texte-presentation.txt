================================================================================
TEXTE DE PRÉSENTATION - SYSTÈME EXPERT ORTHODONTIQUE
================================================================================
Auteurs : Loudiern Tharon & Lou Aubert-Debrue
Date : 19 Décembre 2025
================================================================================

================================================================================
SLIDE 1 : JUSTIFICATION ORDRE 0+
================================================================================

• DÉFINITION ORDRE 0+ :
  - Logique propositionnelle ÉTENDUE avec prédicats de comparaison
  - PAS de variables libres (∀x, ∃x)
  - PAS de quantificateurs universels/existentiels
  - Faits = couples (attribut, valeur) INSTANCIÉS
  - Comparateurs numériques : >, <, >=, <=, =, member

• PREUVES DANS NOTRE CODE :

  1) Structure des faits (lignes 6-11) :
     → (defstruct fait attribut valeur source)
     → Chaque fait est une PROPOSITION ATOMIQUE instanciée
     → Ex: (age = 10) et NON (age = ?x) → pas de variable

  2) Structure des prémisses (ligne 16) :
     → Format : (attribut operateur valeur-constante)
     → Ex: '((age >= 8) (age <= 12) (cooperation equal bonne))
     → Toutes les valeurs sont des CONSTANTES, pas des variables

  3) Fonction evaluer-condition (lignes 183-197) :
     → 6 opérateurs : equal, >, <, >=, <=, member
     → Ce sont des PRÉDICATS sur valeurs concrètes
     → Différence avec Ordre 0 : on dépasse la simple égalité

  4) Opérateur MEMBER (ligne 196) :
     → Extension Ordre 0+ : appartenance à un ensemble FINI
     → Ex: (diagnostic member (classe-2-squel classe-3-squel))
     → L'ensemble est ÉNUMÉRÉ, pas défini par compréhension

• POURQUOI PAS ORDRE 1 ?
  - Pas de règles du type : ∀patient P, SI symptome(P) ALORS traitement(P)
  - Pas de chaînage avec unification de variables
  - Pas de résolution de type Prolog

================================================================================
SLIDE 2 : JUSTIFICATION DES FONCTIONS LISP
================================================================================

• DEFSTRUCT (lignes 6-21) :
  - Crée des types structurés avec accesseurs automatiques
  - AVANTAGE : Sémantique explicite vs listes associatives
  - Génère : fait-attribut, fait-valeur, make-fait, etc.
  - JUSTIFICATION : Lisibilité + typage implicite + maintenance

• DEFPARAMETER (lignes 24-27) :
  - Variables globales modifiables (*base-faits*, *base-regles*)
  - Convention Lisp : *étoiles* pour globales
  - JUSTIFICATION : Mémoire de travail accessible partout

• PUSH / POP :
  - Ajout en tête de liste (O(1))
  - JUSTIFICATION : Performance pour base de faits dynamique
  - Alternative cons moins explicite

• FIND avec :KEY (ligne 34) :
  - Recherche dans liste avec fonction d'extraction
  - JUSTIFICATION : Évite boucle manuelle, idiomatique Lisp
  - Ex: (find attribut *base-faits* :key #'fait-attribut)

• LOOP WHILE (ligne 203) :
  - Boucle de saturation du chaînage avant
  - JUSTIFICATION : Macro puissante, lisible, gère le flag nouveau-fait-trouve

• DOLIST (lignes 208, 217) :
  - Itération sur listes (règles, prémisses)
  - JUSTIFICATION : Plus lisible que mapcar quand effets de bord

• CASE (ligne 188-195) :
  - Dispatch sur opérateur (equal, >, <, etc.)
  - JUSTIFICATION : O(1) vs cascade de IF, extensible

• WHEN / UNLESS :
  - Conditionnels à une branche
  - JUSTIFICATION : Plus clair que (if condition action nil)

• FORMAT avec ~a, ~d, ~% :
  - Affichage formaté pour traces et debug
  - JUSTIFICATION : Standard Lisp, puissant, portable

================================================================================
SLIDE 3 : CHOIX ARCHITECTURAUX DU SE
================================================================================

• CHAÎNAGE AVANT (Forward Chaining) :
  - CHOIX : Partir des données vers les conclusions
  - JUSTIFICATION MÉDICALE :
    → Patient arrive avec SYMPTÔMES (données connues)
    → On cherche le DIAGNOSTIC (but inconnu)
    → Approche "Data-Driven" naturelle en médecine
  - ALTERNATIVE REJETÉE : Chaînage arrière moins adapté ici

• SATURATION (ligne 200-227) :
  - CHOIX : Boucle jusqu'à stabilité (pas de nouveau fait)
  - JUSTIFICATION :
    → Garantit l'exhaustivité des déductions
    → Règles en cascade (diagnostic → appareil → accessoire)
    → Simple à implémenter et débugger

• FLAG ACTIVE (ligne 20, 223) :
  - CHOIX : Désactiver règle après déclenchement
  - JUSTIFICATION :
    → Évite boucles infinies (R déclenchée → refait → R déclenchée...)
    → Garantit terminaison
    → Chaque règle ne s'applique qu'une fois par session

• SÉPARATION MODULES (A/B/C) :
  - Module A : Règles de DIAGNOSTIC (R-A1 à R-A6)
  - Module B : Règles d'APPAREILLAGE (R-B1 à R-B8)
  - Module C : Règles de CONTRE-INDICATION (R-C1 à R-C5)
  - JUSTIFICATION :
    → Modularité = maintenance facilitée
    → Priorité implicite par ordre de chargement
    → Lisibilité pour validation par expert médical

• TRIPLET (attribut operateur valeur) :
  - CHOIX : Format uniforme pour toutes les conditions
  - JUSTIFICATION :
    → Parsing simple dans evaluer-condition
    → Extensible (ajouter un opérateur = 2 lignes)
    → Lisible pour non-informaticiens

• GESTION DU :INCONNU (ligne 186) :
  - CHOIX : Retourner :inconnu si fait absent
  - JUSTIFICATION :
    → Différencie "fait faux" vs "fait non renseigné"
    → Permet questions différées (chaînage arrière)
    → Robustesse aux données incomplètes

• FACTEUR DE CONFIANCE (CF) :
  - CHOIX : Informatif seulement, pas dans l'inférence
  - JUSTIFICATION :
    → Ordre 0+ = logique classique (vrai/faux)
    → CF = métadonnée pour l'utilisateur
    → Évite complexité du calcul probabiliste

================================================================================
SLIDE 4 : AVANTAGES DE L'IMPLÉMENTATION
================================================================================

• ROBUSTESSE :
  - Tests unitaires intégrés (400 lignes de tests)
  - Gestion NIL sécurisée partout
  - Pas de crash sur données manquantes

• TRAÇABILITÉ :
  - Source du fait : :utilisateur ou :deduit
  - Affichage des règles déclenchées
  - Numéro de cycle visible

• EXTENSIBILITÉ :
  - Ajouter une règle = 6 lignes de code
  - Ajouter un opérateur = 2 lignes dans CASE
  - Base de règles séparée du moteur

• PORTABILITÉ :
  - Common Lisp standard (SBCL, CLISP, etc.)
  - Pas de dépendances externes
  - Code auto-documenté (docstrings)

================================================================================
SLIDE 5 : SYNTHÈSE ORDRE 0+ vs ORDRE 1
================================================================================

┌─────────────────────┬───────────────────────┬───────────────────────┐
│ Caractéristique     │ Ordre 0+ (NOTRE SE)   │ Ordre 1 (Prolog)      │
├─────────────────────┼───────────────────────┼───────────────────────┤
│ Variables           │ NON (constantes)      │ OUI (?x, ?y)          │
│ Quantificateurs     │ NON                   │ OUI (∀, ∃)            │
│ Comparateurs        │ OUI (>, <, =, ...)    │ OUI                   │
│ Unification         │ NON                   │ OUI                   │
│ Faits               │ (attr = val)          │ predicat(X, Y)        │
│ Complexité          │ Linéaire              │ Exponentielle         │
└─────────────────────┴───────────────────────┴───────────────────────┘

• NOTRE CHOIX SE JUSTIFIE :
  - Domaine médical = ensemble FINI de patients/symptômes
  - Pas besoin de généralisation (pas de "tout patient tel que...")
  - Performance garantie (pas d'explosion combinatoire)
  - Compréhensible par un praticien non-informaticien

================================================================================
FIN DU DOCUMENT
================================================================================
